
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Java编程思想-第二十一章、并发（五） | 特喜欢秋天的人</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="威威小威">
    

    
    <meta name="description" content="21.5 多个线程之间如何协作？前面对线程进行了讨论，但是比较简单，要么是每个线程独享自己线程内部的资源，要么是用锁机制串行访问共享资源。而本小节做了一点点升级：使用共享资源不再是盲目的阻塞了，而是使用新的握手机制，其实握手类似事件驱动。不过我对事件驱动也只是了解个皮毛，知道大概的 select/kqueue/epoll 原理，具体的还请自行 man 或者 google。我简单举个例子吧：

首先">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程思想-第二十一章、并发（五）">
<meta property="og:url" content="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（五）/index.html">
<meta property="og:site_name" content="特喜欢秋天的人">
<meta property="og:description" content="21.5 多个线程之间如何协作？前面对线程进行了讨论，但是比较简单，要么是每个线程独享自己线程内部的资源，要么是用锁机制串行访问共享资源。而本小节做了一点点升级：使用共享资源不再是盲目的阻塞了，而是使用新的握手机制，其实握手类似事件驱动。不过我对事件驱动也只是了解个皮毛，知道大概的 select/kqueue/epoll 原理，具体的还请自行 man 或者 google。我简单举个例子吧：

首先">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java编程思想-第二十一章、并发（五）">
<meta name="twitter:description" content="21.5 多个线程之间如何协作？前面对线程进行了讨论，但是比较简单，要么是每个线程独享自己线程内部的资源，要么是用锁机制串行访问共享资源。而本小节做了一点点升级：使用共享资源不再是盲目的阻塞了，而是使用新的握手机制，其实握手类似事件驱动。不过我对事件驱动也只是了解个皮毛，知道大概的 select/kqueue/epoll 原理，具体的还请自行 man 或者 google。我简单举个例子吧：

首先">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="特喜欢秋天的人">特喜欢秋天的人</a></h1>
				<h2 class="blog-motto">从春天到秋天，从前端写到后台</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:mwplll.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/Java编程思想-第二十一章、并发（五）/" title="Java编程思想-第二十一章、并发（五）" itemprop="url">Java编程思想-第二十一章、并发（五）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="威威小威" target="_blank" itemprop="author">威威小威</a>
		
  <p class="article-time">
    <time datetime="2015-08-16T18:27:17.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-5_多个线程之间如何协作？"><span class="toc-number">1.</span> <span class="toc-text">21.5 多个线程之间如何协作？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-_wait()和_notifyAll()的使用"><span class="toc-number">1.1.</span> <span class="toc-text">1. wait()和 notifyAll()的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-_虽然使用了_notifyAll(),但是信号一定能被_wait()收到吗？——错失的信号"><span class="toc-number">1.2.</span> <span class="toc-text">2. 虽然使用了 notifyAll(),但是信号一定能被 wait()收到吗？——错失的信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-_notify()_VS_notifyAll()"><span class="toc-number">1.3.</span> <span class="toc-text">3. notify() VS notifyAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-_生产者与消费者"><span class="toc-number">1.4.</span> <span class="toc-text">4. 生产者与消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-_生产者-消费者与队列"><span class="toc-number">1.5.</span> <span class="toc-text">5. 生产者-消费者与队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-_任务间使用管道进行输入/输出"><span class="toc-number">1.6.</span> <span class="toc-text">6. 任务间使用管道进行输入/输出</span></a></li></ol></li></ol>
		
		</div>
		
		<h3 id="21-5_多个线程之间如何协作？">21.5 多个线程之间如何协作？</h3><p>前面对线程进行了讨论，但是比较简单，要么是每个线程独享自己线程内部的资源，要么是用锁机制串行访问共享资源。而本小节做了一点点升级：使用共享资源不再是盲目的阻塞了，而是使用新的握手机制，其实握手类似事件驱动。不过我对事件驱动也只是了解个皮毛，知道大概的 select/kqueue/epoll 原理，具体的还请自行 man 或者 google。我简单举个例子吧：</p>
<ul>
<li>首先要理解阻塞：阻塞是什么呢？假如现在有个快递（共享资源），但是你不知道什么时候能送到自己手里，而且你没有别的事可以干（或者说接下来的事要等快递来了才能做）。那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打个电话（假定一定能叫醒你）</li>
<li>然后是非阻塞忙轮询：如果用忙轮询的方法，那么你需要知道快递员的手机号，然后不停地给他打电话：“你到了没？”</li>
</ul>
<p>这样一看，我们在前面学习的就是阻塞（synchronized 锁）或者非阻塞忙轮询（使用 while(资源不可用) {sleep…}）。这样做不仅效率低，还会大大降低效率，因为对于线程来说，不仅需要保存线程上下文，还要频繁的切换用户态和内核态。而这里解决方法就类似 epoll 那样的回调。</p>
<blockquote>
<p>线程协作简单来说就是对共享资源的使用还是阻塞，但是一旦共享资源释放，会主动给阻塞线程发送信号。这样就不用傻傻等待或者不停轮询了。而协作的关键就是<strong>如何传递这个信号</strong>，在 Java 中我们可以使用 Object 中的 wait()和 notify()/notifyAll()函数，也可以使用 concurrent 类库中提供的 await()和 signal()/signalAll()函数。</p>
</blockquote>
<p>下面我们就来具体学习线程协作的相关知识。如果先大致浏览这一小节的话，会发生节奏非常紧凑：</p>
<ol>
<li>第一小节首先介绍线程协作，以及相关的3个函数： wait()、notify()、notifyAll()，然后用一个凃蜡、喷漆程序演示如何进行线程协作（重点是明白线程为什么可以协作呢？因为 wait()不会一直占有锁，在挂起期间会允许进入其他 synchronized 方法改变条件，从而 notify()后再醒来继续工作）</li>
<li>notify()和 notifyAll()的区别（个人感觉这一节讲的很迷糊，可以自己去 stackoverflow 或者其他地方查资料）</li>
<li>用厨师做菜、服务员上菜演示生产者消费者模型，其实还包括一个用 Lock 和 Condition 实现的凃蜡、喷漆程序，可以和第一小节再对比一下</li>
<li>使用同步队列的方式改变第三小节的生产者消费者模型，用一个队列解耦生产者和消费者</li>
<li>使用管道来进行输入/输出，本质上是生产者消费者模型的变体，<strong>不过它是存在于引入 BlockingQueue 之前的 Java 版本，所以能用 BlockingQueue 的地方就可以忘掉管道了</strong></li>
</ol>
<p>大概了解本节内容之后，就可以进行有的放矢的学习了：）</p>
<h4 id="1-_wait()和_notifyAll()的使用">1. wait()和 notifyAll()的使用</h4><p>话说被书上这个例子坑的很惨，这个例子前前后后看过10遍左右吧，每次看到这都要纠结很久。这次也是弄了好久才算没那么迷糊。。。。。。（智商急需充值啊。。。）嗯，我先来描述这个“简单”的程序吧：</p>
<blockquote>
<p>现在有一辆车，需要对它进行凃蜡和抛光操作。因为存在先后顺序，所以必须先凃蜡，然后在抛光。</p>
</blockquote>
<p>场景说完了，show code:</p>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>{
    <span class="javadoc">/**
     * true： 凃蜡&lt;br&gt;
     * false：抛光
     */</span>
    <span class="keyword">private</span> <span class="keyword">boolean</span> waxOn = <span class="keyword">false</span>;

    <span class="comment">// 完成凃蜡，可以进行抛光了</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waxed</span><span class="params">()</span> </span>{
        waxOn = <span class="keyword">true</span>;
        notifyAll();
    }

    <span class="comment">// 完成抛光，可以进行下一层凃蜡了</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">buffed</span><span class="params">()</span> </span>{
        waxOn = <span class="keyword">false</span>;
        notifyAll();
    }

    <span class="comment">// 这里为什么要用 while()不断监测？为什么不用 if()？</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{
        <span class="keyword">while</span> (waxOn == <span class="keyword">false</span>) {
            wait();
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">waitForBuffing</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{
        <span class="keyword">while</span> (waxOn == <span class="keyword">true</span>) {
            wait();
        }
    }
}

<span class="comment">// 凃蜡任务。因为凃蜡肯定先发生，所以步骤为凃蜡-等待抛光-凃蜡</span>
<span class="class"><span class="keyword">class</span> <span class="title">WaxOn</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> Car car;
    <span class="function"><span class="keyword">public</span> <span class="title">WaxOn</span><span class="params">(Car c)</span> </span>{
        <span class="keyword">this</span>.car = c;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                System.out.println(<span class="string">"开始凃蜡..."</span>);
                TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);
                car.waxed();
                car.waitForBuffing();
            }
         } <span class="keyword">catch</span>(InterruptedException e) {
             System.out.println(<span class="string">"Exit via interrupt"</span>);
         }
        System.out.println(<span class="string">"结束凃蜡任务"</span>);
    }
}

<span class="comment">// 抛光任务。先行任务为凃蜡，所以步骤为等待凃蜡-抛光-等待凃蜡</span>
<span class="class"><span class="keyword">class</span> <span class="title">WaxOff</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> Car car;
    <span class="function"><span class="keyword">public</span> <span class="title">WaxOff</span><span class="params">(Car car)</span> </span>{
        <span class="keyword">this</span>.car = car;
    }
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                car.waitForWaxing();
                System.out.println(<span class="string">"开始抛光..."</span>);
                TimeUnit.MICROSECONDS.sleep(<span class="number">200</span>);
                car.buffed();
            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.println(<span class="string">"Exit via interupt"</span>);
        }
        System.out.println(<span class="string">"结束抛光任务"</span>);
    }
}

<span class="comment">/*
 * 特意先开始抛光任务，再开始凃蜡任务
 */</span>
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaxOMatic</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>{
        Car car = <span class="keyword">new</span> Car();
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(<span class="keyword">new</span> WaxOff(car));
        exec.execute(<span class="keyword">new</span> WaxOn(car));
        TimeUnit.SECONDS.sleep(<span class="number">5</span>);
        exec.shutdownNow();
    }
}
</code></pre><p>整个程序的逻辑很简单，但是一定要理解 boolean 类型的 waxOn 变量所代表的含义。其实我到现在也没明白。。。。。。。。不过不影响看懂整个程序的逻辑：</p>
<ol>
<li>首先定义一个车，waxed()代表凃蜡完成，buffed()代表抛光完成。waitForWaxing()等待凃蜡，如果 waxOn = false 就说明还在抛光；waitForBuffing()等待抛光，如果 waxOn = true 就说明还在凃蜡。（但是waxOn 究竟代表完成，还是进行中呢？如果代表完成，那么 waitForWaxing()的 waxOn = false 就代表抛光完成，可以进行凃蜡了。明明可以工作了好吗！！！竟然是 wait()。正好和我理解的相反；如果理解成进行中，那么 waxed()中又立即调用了 notifyAll()，明显是完成了凃蜡的意思。）</li>
<li>WaxOn 就是凃蜡了，因为这个肯定是起始动作。所以 run()中先进行凃蜡，然后等待抛光</li>
<li>WaxOff 就是抛光了，因为它肯定在凃蜡操作后执行，所以 run()中先等凃蜡完成后才能进行抛光操作，抛光完成后就再等待下一次凃蜡完成。</li>
<li>main()为了突出这个逻辑，特意先调用了抛光过程，这个希望你能注意到（感觉作者对每个例子都好用心的T_T）</li>
</ol>
<p>一定要多看看其中是如何使用 wait()和 nofityAll()，如果能提出问题就更好了。一个非常值得思考的问题是：为什么 wait()要使用 while()去监测，既然 notifyAll()发送了资源可用的信号，那么 wait()收到这个消息，用 if()就足够了呀。这是为什么呢？原因如下：</p>
<ul>
<li>可能有多个任务出于相同的原因在等待同一个锁，而第一个唤醒任务可能会改变这种状况（即使你没有这么做，有人也会通过继承你的类去这么做）。如果属于这种情况，那么<strong>这个任务应该被再次挂起，直至其感兴趣的条件发生变化</strong></li>
<li>在这里任务从其 wait()中被唤醒的时刻，有可能会有某个其他的任务已经做出了改变，从而使得这个任务在此时不能执行，或者执行其操作已经显得无关紧要。此时，应该通过再次调用 wait()来将其重新挂起。</li>
<li>也有可能某些任务出于不用的原因在等待你的对象上的锁（在这种情况下必须使用 notifyAll())。在这种情况下，你需要检查是否已经由正确的原因唤醒，如果不是，就再次调用 wait()。</li>
</ul>
<p>因此，总结一下上面的要点：</p>
<blockquote>
<p><strong>其本质就是要检查所感兴趣的特定条件，并在条件不满足的情况下返回到 wait()中。惯用的方法就是使用 while 来编写 wait()的代码。</strong>而且 wait()有两种使用，一种是指定到期时间，一种是无限等待。一般情况下我们都会使用无限等待，因为条件很多情况下是无法得知改变的大概时间的。</p>
</blockquote>
<p>然后还有一个有趣的问题：wait()/notify()/notifyAll()既然都是关于线程协作方面的，为什么它们是在基类 Object 中实现而不是 Thread 中实现呢？</p>
<blockquote>
<p>尽管乍一想有点奇怪，但是我们来分析一下。锁存在于<strong>所有对象的对象头</strong>中，所以任何同步控制的地方都用到了锁，而用到锁的地方当然也可以进行线程协作。如果把这3个方法实现在 Thread 中，那么使用线程协作的范围就会缩小到继承了 Thread 或者实现了 Runnable 接口的类的对象中，而不是所有对象。实际上，也<strong>只能在同步控制块中调用 wait()、notify()、notifyAll()，因为它们都和锁关联，而 sleep()因为不用操作锁，所以可以在非同步控制方法中调用</strong>，如果在非同步控制方法中调用了这3个方法，程序能够通过编译，不过在运行的时候，将得到 IllegalMonitorStateException 异常，并伴随着一些含糊的信息，比如“当前线程不是拥有者”。消息的意思是，调用 wait()、notify()、notifyAll()的任务在调用这些方法前必须“拥有”（获取）对象的锁。</p>
</blockquote>
<h4 id="2-_虽然使用了_notifyAll(),但是信号一定能被_wait()收到吗？——错失的信号">2. 虽然使用了 notifyAll(),但是信号一定能被 wait()收到吗？——错失的信号</h4><p>当线程使用 wait()/notify()或者 wait()/notifyAll()时，均可能发生错失信号的问题。想想这是什么原因呢？比如下面这段代码你能看出问题吗？</p>
<pre><code>T1:
    <span class="keyword">synchronized</span>(sharedMonitor) {
        &lt;setup condition <span class="keyword">for</span> T2&gt;
        shareMonitor.notify();
    }

T2:
    <span class="keyword">while</span>(someCondition) {
        <span class="comment">//Point 1</span>
        <span class="keyword">synchronized</span>(sharedMonitor) {
            sharedMonitor.wait();
        }
    }    
</code></pre><p>两个线程 T1和 T2的协作正确吗？如果不正确，会发生什么问题呢？</p>
<blockquote>
<p>其实代码中已经有了提示，在 Point 1处可能会发生错误。假如 T2执行到 Point 1的时候，说明someCondition 为 true，而这时线程调度器将时间片分给 T1，T1检查 sharedMonitor 对象锁没有占用，就拿到锁进入到同步控制块中，改变T2 线程的 while 条件，然后发送一个信号。但是因为 T2已经执行过 someCondition 的判断，所以就错失了 notify（）的通知，在同步控制块中 wait（）导致死锁（一直等待）。</p>
</blockquote>
<p>那么，解决办法是防止在 someCondition 上产生变量竞争条件。不竞争不就是串行的意思嘛，所以 T2的代码将 while()放在同步控制块中即可：</p>
<pre><code><span class="keyword">synchronized</span>(sharedMonitor) {
    <span class="keyword">while</span>(someCondition) {
        sharedMonitor.wait();
    }
}    
</code></pre><h4 id="3-_notify()_VS_notifyAll()">3. notify() VS notifyAll()</h4><p>如果仔细观察上面的程序，会发现我们一会用 notifyAll()一会用 notify(),那么它们各自的使用场景是什么？</p>
<p>其实从名字可以猜个大概，notify()是对于单个线程来说的，notifyAll()是对于所有线程而言的。举个例子，现在大家都在教室自习，有个家长来找自己的孩子，那么 notify()就是去那个家长的孩子座位上单独告诉他，notifyAll()就是在班里大吼一声某某的家长在外面，让所有学生都知道，然后某某出去，其他孩子继续干自己的事情。</p>
<p>实际上，notify()和 notifyAll()的区别还是非常值得研究的，stackoverflow 上也有这个问题的讨论：<a href="http://stackoverflow.com/questions/37026/java-notify-vs-notifyall-all-over-again#" target="_blank" rel="external">Java: notify() vs. notifyAll() all over again</a></p>
<h4 id="4-_生产者与消费者">4. 生产者与消费者</h4><pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>{
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> orderNum;

    <span class="function"><span class="keyword">public</span> <span class="title">Meal</span><span class="params">(<span class="keyword">int</span> orderNum)</span> </span>{
        <span class="keyword">this</span>.orderNum = orderNum;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"Meal "</span> + orderNum;
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> Restaurant restaurant;

    <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(Restaurant restaurant)</span> </span>{
        <span class="keyword">this</span>.restaurant = restaurant;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (!Thread.interrupted()) {
                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                    <span class="keyword">while</span> (restaurant.meal == <span class="keyword">null</span>) {
                        wait();
                    }
                }
                System.out.println(<span class="string">"Waiter got "</span> + restaurant.meal);
                <span class="comment">// 为什么要选择 chef 作为同步控制块的锁呢？</span>
                <span class="comment">// 废话，想通知 chef，肯定要调用 chef.notifyAll()。因为 notifyAll()必须在</span>
                <span class="comment">// 同步控制块中调用，而且释放的是 chef 的锁，肯定需要先获取 chef 的锁了。。。</span>
                <span class="keyword">synchronized</span> (restaurant.chef) {
                    restaurant.meal = <span class="keyword">null</span>;
                    restaurant.chef.notifyAll(); <span class="comment">// 准备下一道菜</span>
                }
            }
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.out.println(<span class="string">"Waiter interrupted"</span>);
        }
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Chef</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> Restaurant restaurant;
    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;

    <span class="function"><span class="keyword">public</span> <span class="title">Chef</span><span class="params">(Restaurant restaurant)</span> </span>{
        <span class="keyword">this</span>.restaurant = restaurant;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (!Thread.interrupted()) {
                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {
                    <span class="keyword">while</span> (restaurant.meal != <span class="keyword">null</span>) {
                        wait();
                    }
                }

                <span class="keyword">if</span> (++count == <span class="number">11</span>) {
                    System.out.println(<span class="string">"菜上齐了"</span>);
                    <span class="comment">//这块只是向 chef 和 waiter 发送一个 interrupt 信号</span>
                    <span class="comment">//但是因为 synchronized 和 IO 是不能被中断的，所以这里会通过可中断的</span>
                    <span class="comment">//sleep()抛出 InterruptedException。</span>
                    <span class="comment">//而 waiter 只能通过 while(Thread.interrupted())抛出的 InterruptedException返回</span>

                    <span class="comment">//而且我们会发现，多做了一个菜！本来做了10个就够了。11个本意想关闭程序，但是因为</span>
                    <span class="comment">//synchronized 无法中断，只好又做了一个菜（厨师也饿了）。但是因为服务员在 wait()，可以被中断</span>
                    <span class="comment">//所以做好的菜没有被服务员上去。。。。</span>
                    restaurant.exec.shutdownNow();
                }

                System.out.print(<span class="string">"做菜ing..."</span>);
                <span class="keyword">synchronized</span> (restaurant.waiter) {
                    restaurant.meal = <span class="keyword">new</span> Meal(count);
                    restaurant.waiter.notifyAll();
                }

                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
            }
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.out.println(<span class="string">"chef interrupted"</span>);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span> </span>{
    Meal meal;
    ExecutorService exec = Executors.newCachedThreadPool();
    Waiter waiter = <span class="keyword">new</span> Waiter(<span class="keyword">this</span>);
    Chef chef = <span class="keyword">new</span> Chef(<span class="keyword">this</span>);

    <span class="function"><span class="keyword">public</span> <span class="title">Restaurant</span><span class="params">()</span> </span>{
        exec.execute(chef);
        exec.execute(waiter);
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="keyword">new</span> Restaurant();
    }
}<span class="comment">/*output:
做菜ing...Waiter got Meal 1
做菜ing...Waiter got Meal 2
做菜ing...Waiter got Meal 3
做菜ing...Waiter got Meal 4
做菜ing...Waiter got Meal 5
做菜ing...Waiter got Meal 6
做菜ing...Waiter got Meal 7
做菜ing...Waiter got Meal 8
做菜ing...Waiter got Meal 9
做菜ing...Waiter got Meal 10
菜上齐了
Waiter interrupted
做菜ing...chef interrupted
*/</span>
</code></pre><p>这个程序的输出会发现，最后一道菜已经做了，但是没有上。写完迷糊了好久才想起来，synchronized 不可被中断，但是 wait()可以被中断啊（同时中断状态被清除，抛出一个 InterruptedException）！！！！</p>
<h4 id="5-_生产者-消费者与队列">5. 生产者-消费者与队列</h4><p>上面是生产者消费者模型的最基本实现——厨师做完一道菜后通知服务员取菜，服务员取菜之后通知厨师做菜。这样的做法太低效，因为每次交互都需要握手。在更高效的程序中，可以使用<strong>同步队列</strong>来解决任务协作问题，<strong>同步队列在任何时刻都只允许一个任务插入或移除元素</strong>。在 java.util.concurrent.BlockingQueue 接口中提供了这种队列，这个接口有大量的标准实现。通常可以使用 LinkedBlockingQueue，它是一个无界队列，还可以使用 ArrayBlockingQueue，它又固定的大小，因此可以在它被阻塞之前向其中放置有限数量的元素。</p>
<p>并且，使用同步队列可以简化上面繁琐的握手方式。如果消费者任务试图从队列中获取元素，而该队列为空，那么这些队列还可以挂起消费者任务，当有更多的元素可用时，又会恢复消费者任务。阻塞队列可以解决非常大量的问题，而方式与 wait()和 notifyAll()相比，则简单可靠的多。</p>
<p>下面我们写一个简单的程序说明一下 BlockingQueue 的使用方法，以及它带来的便利。</p>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.io.<span class="keyword">BufferedReader</span>;
<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.InputStreamReader;
<span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;
<span class="keyword">import</span> java.util.concurrent.BlockingQueue;
<span class="keyword">import</span> java.util.concurrent.LinkedBlockingDeque;
<span class="keyword">import</span> java.util.concurrent.SynchronousQueue;

class LiftOffRunner implements Runnable {
    <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;

    <span class="keyword">public</span> LiftOffRunner(BlockingQueue&lt;LiftOff&gt; rockets) {
        <span class="keyword">this</span>.rockets = rockets;
    }

    <span class="comment">//生产者</span>
    <span class="keyword">public</span> <span class="keyword">void</span> <span class="built_in">add</span>(LiftOff lo) {
        <span class="keyword">try</span> {
            rockets.put(lo);
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.<span class="built_in">println</span>(<span class="string">"Interrupted during put()"</span>);
        }
    }

    <span class="comment">//消费者——注意后面的程序先启动了消费者。</span>
    <span class="keyword">public</span> <span class="keyword">void</span> run() {
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                LiftOff rocket = rockets.take();
                rocket.run();
            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.<span class="built_in">println</span>(<span class="string">"waking from take()"</span>);
        }
        System.out.<span class="built_in">println</span>(<span class="string">"Exiting LiftOffRunner"</span>);
    }
}

<span class="keyword">public</span> class TestBlockingQueues {
    <span class="comment">/**
     * 其实getkey()仅仅是为了隔开 BlockingQueue 的不同实现类。
     */</span>
    <span class="keyword">static</span> <span class="keyword">void</span> getkey() {
        <span class="keyword">try</span> {
            <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in)).readLine();
        } <span class="keyword">catch</span>(IOException e) {
            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
        }
    }

    <span class="keyword">static</span> <span class="keyword">void</span> getkey(<span class="keyword">String</span> message) {
        System.out.<span class="built_in">println</span>(message);
        getkey();
    }

    <span class="comment">/**
     * 每次测试一种 BlockingQueue 的实现。其中先调用t.start()是为了启动消费者。
     * 因为没有启动生产者，所以 BlockingQueue 会自动挂起。然后使用 for 循环生产 rockets 的元素。
     * 
     * 所以不仅实例了 BlockingQueue 作为一个 Queue 的使用，也演示了当生产者或者消费者阻塞时，BlockingQueue
     * 会自动帮我们处理，使我们可以专注于业务逻辑。
     */</span>
    <span class="keyword">static</span> <span class="keyword">void</span> test(<span class="keyword">String</span> msg, BlockingQueue&lt;LiftOff&gt; queue) {
        System.out.<span class="built_in">println</span>(msg);
        LiftOffRunner runner = <span class="keyword">new</span> LiftOffRunner(queue);
        Thread t = <span class="keyword">new</span> Thread(runner);
        t.start();
        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
            runner.<span class="built_in">add</span>(<span class="keyword">new</span> LiftOff(<span class="number">5</span>));
        }
        getkey(<span class="string">"Press 'Enter' ("</span> + msg + <span class="string">")"</span>);
        t.interrupt();
        System.out.<span class="built_in">println</span>(<span class="string">"Finished "</span> + msg + <span class="string">" test"</span>);
    }

    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) {
        test(<span class="string">"LinkedBlockingQueue"</span>, <span class="keyword">new</span> LinkedBlockingDeque&lt;LiftOff&gt;());
        test(<span class="string">"ArrayBlockingQueue"</span>, <span class="keyword">new</span> ArrayBlockingQueue&lt;LiftOff&gt;(<span class="number">3</span>));
        test(<span class="string">"SynchronousQueue"</span>, <span class="keyword">new</span> SynchronousQueue&lt;LiftOff&gt;());
    }
}
</code></pre><p>程序的输出需要 System.in，所以自己去运行。运行之后，你的任务是再写一个程序。将厨师、服务员的例子改写成使用 BlockingQueue 的。我也来一发：</p>
<pre><code>package concurrency;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;


/**
 * 这个例子的一个收获是：
 * 
 * 想要抛出异常必须得有载体。比如：
 * 
 * <span class="keyword">while</span>(!Thread.interrupted()) {
 * }
 * 
 * 是不会抛出异常的。
 * 
 * 只有当里面有 sleep()/wait()/join()在运行（让线程处于阻塞状态），然后才能从阻塞状态退出，
 * 并抛出一个 InterruptedException。
 * 
 */

class NewMeal {
    private final int orderNum;

    public NewMeal(int orderNum) {
        this.orderNum = orderNum;
    }

    public String toString() {
        <span class="keyword">return</span> <span class="string">"Meal "</span> + orderNum;
    }
}

class NewWaiter implements Runnable {
    private RestaurantWithBlockingQueue restaurant;

    public NewWaiter(RestaurantWithBlockingQueue restaurant) {
        this.restaurant = restaurant;
    }

    @Override
    public void run() {
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (!Thread.interrupted()) {
                <span class="keyword">while</span> (!restaurant.meal.isEmpty()) {
                    NewMeal meal = restaurant.meal.take();
                    System.out.println(<span class="string">"Waiter got "</span> + meal);
                }
            }
        } catch (InterruptedException e) {
            System.out.println(<span class="string">"Interrupted waiter"</span>);
        }
    }
}

class NewChef implements Runnable {
    private RestaurantWithBlockingQueue restaurant;

    public NewChef(RestaurantWithBlockingQueue restaurant) {
        this.restaurant = restaurant;
    }

    @Override
    public void run() {
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (!Thread.interrupted()) {
                <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">11</span>; i++) {

                    <span class="keyword">if</span> (i == <span class="number">11</span>) {
                        restaurant.exec.shutdownNow();
                        continue;
                    }

                    System.out.println(<span class="string">"做菜..."</span>);
                    restaurant.meal.add(new NewMeal(i));
                    TimeUnit.MILLISECONDS.sleep(<span class="number">100</span>);
                }
            }
        } catch (InterruptedException e) {
            System.out.println(<span class="string">"Interrupted chef"</span>);
        }
    }
}

public class RestaurantWithBlockingQueue {
    LinkedBlockingQueue&lt;NewMeal&gt; meal = new LinkedBlockingQueue&lt;NewMeal&gt;();
    ExecutorService exec = Executors.newCachedThreadPool();
    NewWaiter waiter = new NewWaiter(this);
    NewChef chef = new NewChef(this);

    public RestaurantWithBlockingQueue() {
        exec.execute(waiter);
        exec.execute(chef);

    }

    public static void main(String[] args) {
//        <span class="keyword">while</span>(!Thread.interrupted()) {
//            System.out.println(<span class="string">"ehl"</span>);
//        }
        new RestaurantWithBlockingQueue();
    }
}/*output:
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">1</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">2</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">3</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">4</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">5</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">6</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">7</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">8</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">9</span>
做菜<span class="keyword">...</span>
Waiter got Meal <span class="number">10</span>
*/
</code></pre><p>通过这个程序得出的结论是：</p>
<ul>
<li>如果线程没有被阻塞，调用 interrupt()将不起作用；若线程处于阻塞状态，就将得到异常（该线程必须事先预备好处理此状况），接着退出阻塞状态。 </li>
<li>线程 A 在执行 sleep(),wait(),join()时,线程 B 调用 A 的 interrupt 方法,A会 catch 一个 InterruptedException异常.但这其实是在 sleep,wait,join 这些方法内部不断检查中断状态的值后抛出的 InterruptedException。 </li>
<li>如果线程 A 正在执行一些指定的操作时，如赋值、for、while等,线程本身是不会去检查中断状态标志的,所以线程 A 自身不会抛出 InterruptedException 而是一直执行自己的操作。</li>
<li>当线程 A 终于执行到 wait(),sleep(),join()时,这些方法本身会抛出 InterruptedException</li>
<li>若没有调用 sleep(),wait(),join()这些方法,或是没有在线程里自己检查中断状态并抛出 InterruptedException 的话,那么上游是无法感知这个异常的（还记得异常不能跨线程传递吗？） </li>
</ul>
<p>然后书上还有一个使用 BlockingQueue 的例子，非常简单。本质来说，BlockingQueue 可以当成是一个任务队列，它会自动的搞定同步操作，所以在处理生产者消费者模型时，可以作为首选。当然，使用具体哪种 BlockingQueue 就需要自己选择了。</p>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.util.Random;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="class"><span class="keyword">class</span> <span class="title">Toast</span> </span>{
    <span class="keyword">public</span> <span class="keyword">enum</span> Status {
        DRY, BUTTERED, JAMMED
    };

    <span class="keyword">private</span> Status status = Status.DRY;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;

    <span class="function"><span class="keyword">public</span> <span class="title">Toast</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{
        <span class="keyword">this</span>.id = id;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">butter</span><span class="params">()</span> </span>{
        status = Status.BUTTERED;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jam</span><span class="params">()</span> </span>{
        status = Status.JAMMED;
    }

    <span class="function"><span class="keyword">public</span> Status <span class="title">getStatus</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> status;
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> id;
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"Toast "</span> + id + <span class="string">": "</span> + status;
    }

}

<span class="javadoc">/**
 * ToastQueue 充当别名的作用。就好像 typedef
 *
 */</span>
<span class="class"><span class="keyword">class</span> <span class="title">ToastQueue</span> <span class="keyword">extends</span> <span class="title">LinkedBlockingQueue</span>&lt;<span class="title">Toast</span>&gt; </span>{

}

<span class="comment">//制造吐司</span>
<span class="class"><span class="keyword">class</span> <span class="title">Toaster</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> ToastQueue toastQueue;
    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);
    <span class="function"><span class="keyword">public</span> <span class="title">Toaster</span><span class="params">(ToastQueue toastQueue)</span> </span>{
        <span class="keyword">this</span>.toastQueue = toastQueue;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                TimeUnit.MILLISECONDS.sleep(<span class="number">100</span> + rand.nextInt(<span class="number">500</span>));
                Toast toast = <span class="keyword">new</span> Toast(count++);
                System.out.println(toast);
                toastQueue.add(toast);
            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.println(<span class="string">"制造吐司 is interrupted!"</span>);
        }
        System.out.println(<span class="string">"Toaster off"</span>);
    }
}

<span class="comment">//抹黄油</span>
<span class="class"><span class="keyword">class</span> <span class="title">Butterer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> ToastQueue dryQueue, butteredQueue;
    <span class="function"><span class="keyword">public</span> <span class="title">Butterer</span><span class="params">(ToastQueue dryQueue, ToastQueue butteredQueue)</span> </span>{
        <span class="keyword">this</span>.dryQueue = dryQueue;
        <span class="keyword">this</span>.butteredQueue = butteredQueue;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                Toast toast = dryQueue.take();
                toast.butter();
                System.out.println(toast);
                butteredQueue.put(toast);
            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.println(<span class="string">"抹黄油 is interrupted!"</span>);
        }
        System.out.println(<span class="string">"Butterer off"</span>);
    }
}

<span class="comment">//抹果酱</span>
<span class="class"><span class="keyword">class</span> <span class="title">Jammer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> ToastQueue butteredQueue, finishedQueue;
    <span class="function"><span class="keyword">public</span> <span class="title">Jammer</span><span class="params">(ToastQueue butteredQueue, ToastQueue finishedQueue)</span> </span>{
        <span class="keyword">this</span>.butteredQueue = butteredQueue;
        <span class="keyword">this</span>.finishedQueue = finishedQueue;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                Toast toast = butteredQueue.take();
                toast.jam();
                System.out.println(toast);
                finishedQueue.put(toast);
            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.println(<span class="string">"抹果酱 is interrupted!"</span>);
        }
        System.out.println(<span class="string">"Jammer off"</span>);
    }
}

<span class="comment">//吃吃吃</span>
<span class="class"><span class="keyword">class</span> <span class="title">Eater</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> ToastQueue finishedQueue;
    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;
    <span class="function"><span class="keyword">public</span> <span class="title">Eater</span><span class="params">(ToastQueue finishedQueue)</span> </span>{
        <span class="keyword">this</span>.finishedQueue = finishedQueue;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span>(!Thread.interrupted()) {
                Toast toast = finishedQueue.take();
                <span class="comment">//检查吐司是否按照 order 送来，而且所有都是经过黄油、果酱加工</span>
                <span class="keyword">if</span>(toast.getId() != count++ || toast.getStatus() != Toast.Status.JAMMED) {
                    System.err.println(<span class="string">"Error: "</span> + toast);
                    System.exit(<span class="number">1</span>);
                } <span class="keyword">else</span> {
                    System.out.println(<span class="string">"真好吃啊！！！"</span>);
                }

            }
        } <span class="keyword">catch</span>(InterruptedException e) {
            System.out.println(<span class="string">"吃吃吃 is interrupted!"</span>);
        }
        System.out.println(<span class="string">"Eater off"</span>);
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToastMatic</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        ToastQueue dryQueue = <span class="keyword">new</span> ToastQueue(),
                butteredQueue = <span class="keyword">new</span> ToastQueue(),
                finishedQueue = <span class="keyword">new</span> ToastQueue();
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(<span class="keyword">new</span> Toaster(dryQueue));
        exec.execute(<span class="keyword">new</span> Butterer(dryQueue, butteredQueue));
        exec.execute(<span class="keyword">new</span> Jammer(butteredQueue, finishedQueue));
        exec.execute(<span class="keyword">new</span> Eater(finishedQueue));

        TimeUnit.SECONDS.sleep(<span class="number">5</span>);
        exec.shutdownNow();
    }
}
</code></pre><p>这个程序虽然简单，但是有几个亮点值得关注：</p>
<ul>
<li>Toast 是一个使用 enum 的优秀示例</li>
<li>程序中没有显式的 Lock 或者 synchronized 关键字，就显得很简洁。同步全部由同步队列隐式管理了——每个 Toast 在任何时刻都只由一个任务在操作。</li>
<li>因为队列自动进行阻塞、挂起、恢复，就使得程非常简洁，而且省略了 wait()/notifyAll()在类与类之间的耦合，因为每个类都只和它自己的 BlockingQueue 进行通信</li>
</ul>
<h4 id="6-_任务间使用管道进行输入/输出">6. 任务间使用管道进行输入/输出</h4><p>首先需要声明：</p>
<blockquote>
<p>这个模型可以看成是生产者-消费者问题的变体，这里的管道就是一个封装好的解决方案。管道基本上是一个阻塞队列，<strong>存在于多个引入 BlockingQueue 之前的 Java 版本中</strong>。意思很明显，有了 BlockingQueue 之后还是用 BlockingQueue 吧。目测公司的 jdk 都是1.6+吧，所以这个小节基本就是有个印象就好，重点还是掌握 BlockingQueue。</p>
</blockquote>
<p>下面这个程序虽然简单，但是最好自己多调试。看看 PipedReader 和 PipedWriter 能不能中断，是 IOException 还是 InterruptedException（其实是java.io.InterruptedIOException）。</p>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.io.IOException;
<span class="keyword">import</span> java.io.PipedReader;
<span class="keyword">import</span> java.io.PipedWriter;
<span class="keyword">import</span> java.util.Random;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="javadoc">/**
 * PipedWriter.write()和 PipedReader.read() 都可以中断，这是和普通 IO 之间最重要的区别了。
 */</span>
<span class="class"><span class="keyword">class</span> <span class="title">Sender</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);
    <span class="keyword">private</span> PipedWriter out = <span class="keyword">new</span> PipedWriter();

    <span class="function"><span class="keyword">public</span> PipedWriter <span class="title">getPipedWriter</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> out;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="comment">//while (true) {</span>
                <span class="keyword">for</span>(Integer i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) {
                    out.write(i);
                    <span class="comment">//TimeUnit.MILLISECONDS.sleep(rand.nextInt(500));</span>
                }
            <span class="comment">//}</span>
        } <span class="keyword">catch</span> (IOException e) {
            System.out.println(e + <span class="string">" Sender write exception"</span>);
        }
<span class="comment">//        } catch (InterruptedException e) {</span>
<span class="comment">//            System.out.println(e + " Sender sleep interrupted");</span>
<span class="comment">//        }</span>
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> PipedReader in;

    <span class="comment">//必须和一个 PipedWriter 相关联</span>
    <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(Sender sender)</span> <span class="keyword">throws</span> IOException </span>{
        in = <span class="keyword">new</span> PipedReader(sender.getPipedWriter());
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (<span class="keyword">true</span>) {
                <span class="comment">//调用 P ipedReader.read()，如果管道没有数据会自动阻塞</span>
                System.out.print(<span class="string">"Read: "</span> + (<span class="keyword">char</span>) in.read() + <span class="string">", "</span>);
            }
        } <span class="keyword">catch</span> (IOException e) {
            System.out.println(e + <span class="string">" Receiver read exception"</span>);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PipedIO</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        Sender sender = <span class="keyword">new</span> Sender();
        Receiver receiver = <span class="keyword">new</span> Receiver(sender);
        ExecutorService exec = Executors.newCachedThreadPool();
        exec.execute(sender);
        exec.execute(receiver);

        TimeUnit.SECONDS.sleep(<span class="number">1</span>);
        exec.shutdownNow();
    }
}
</code></pre><p>开头就说了，现在 PipedWriter 和 PipedReader 已经被 BlockingQueue 取代，所以了解即可。记住一点，PipedWriter 和 PipedReader 是可以被中断的。</p>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java编程思想/">Java编程思想</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（五）/" data-title="Java编程思想-第二十一章、并发（五） | 特喜欢秋天的人" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/17/Java编程思想-第二十一章、并发（六）/" title="Java编程思想-第二十一章、并发（六）">
  <strong>上一篇：</strong><br/>
  <span>
  Java编程思想-第二十一章、并发（六）</span>
</a>
</div>


<div class="next">
<a href="/2015/08/17/Java编程思想-第二十一章、并发（四）/"  title="Java编程思想-第二十一章、并发（四）">
 <strong>下一篇：</strong><br/> 
 <span>Java编程思想-第二十一章、并发（四）
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/17/Java编程思想-第二十一章、并发（五）/" data-title="Java编程思想-第二十一章、并发（五）" data-url="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（五）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-5_多个线程之间如何协作？"><span class="toc-number">1.</span> <span class="toc-text">21.5 多个线程之间如何协作？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-_wait()和_notifyAll()的使用"><span class="toc-number">1.1.</span> <span class="toc-text">1. wait()和 notifyAll()的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-_虽然使用了_notifyAll(),但是信号一定能被_wait()收到吗？——错失的信号"><span class="toc-number">1.2.</span> <span class="toc-text">2. 虽然使用了 notifyAll(),但是信号一定能被 wait()收到吗？——错失的信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-_notify()_VS_notifyAll()"><span class="toc-number">1.3.</span> <span class="toc-text">3. notify() VS notifyAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-_生产者与消费者"><span class="toc-number">1.4.</span> <span class="toc-text">4. 生产者与消费者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-_生产者-消费者与队列"><span class="toc-number">1.5.</span> <span class="toc-text">5. 生产者-消费者与队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-_任务间使用管道进行输入/输出"><span class="toc-number">1.6.</span> <span class="toc-text">6. 任务间使用管道进行输入/输出</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C">C<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/Linux/" title="Linux">Linux<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/markdown/" title="markdown">markdown<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/前端/" title="前端">前端<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/求职笔试面试/" title="求职笔试面试">求职笔试面试<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/笔试面试/" title="笔试面试">笔试面试<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>27</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>27</sup></a></li>
			
		
			
				<li><a href="/tags/Java编程思想/" title="Java编程思想">Java编程思想<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/排序/" title="排序">排序<sup>11</sup></a></li>
			
		
			
				<li><a href="/tags/树/" title="树">树<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/基础/" title="基础">基础<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/图/" title="图">图<sup>4</sup></a></li>
			
		
			
				<li><a href="/tags/c/" title="c">c<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/经验/" title="经验">经验<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/数据结构/" title="数据结构">数据结构<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/leetcode/" title="leetcode">leetcode<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/散列/" title="散列">散列<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/鸟哥的Linux私房菜/" title="鸟哥的Linux私房菜">鸟哥的Linux私房菜<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/前端/" title="前端">前端<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/学习资料/" title="学习资料">学习资料<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/堆/" title="堆">堆<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Linux/" title="Linux">Linux<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Mao Weipeng in ZJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:maoweipeng@126.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="威威小威">威威小威</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"mwplll"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fnull' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
