
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Java编程思想-第二十一章、并发（七） | 特喜欢秋天的人</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="威威小威">
    

    
    <meta name="description" content="21.7 新类库中的构件Java SE5的 java.util.concurrent 包中引入了大量设计用来解决并发问题的新类。学习这些“工具类”就可以专注于自己想要实现的功能而不是线程的同步、死锁等一堆令人头疼的细节。这一小节内容非常多，建议的学习方法是：

首先看目录，了解这一小节主要讲的是哪几种构件
通过构件的名字猜猜它们想实现的功能，然后通过查询文档总结一下每个构件的特点，适用的场景
尝试">
<meta property="og:type" content="article">
<meta property="og:title" content="Java编程思想-第二十一章、并发（七）">
<meta property="og:url" content="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（七）/index.html">
<meta property="og:site_name" content="特喜欢秋天的人">
<meta property="og:description" content="21.7 新类库中的构件Java SE5的 java.util.concurrent 包中引入了大量设计用来解决并发问题的新类。学习这些“工具类”就可以专注于自己想要实现的功能而不是线程的同步、死锁等一堆令人头疼的细节。这一小节内容非常多，建议的学习方法是：

首先看目录，了解这一小节主要讲的是哪几种构件
通过构件的名字猜猜它们想实现的功能，然后通过查询文档总结一下每个构件的特点，适用的场景
尝试">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java编程思想-第二十一章、并发（七）">
<meta name="twitter:description" content="21.7 新类库中的构件Java SE5的 java.util.concurrent 包中引入了大量设计用来解决并发问题的新类。学习这些“工具类”就可以专注于自己想要实现的功能而不是线程的同步、死锁等一堆令人头疼的细节。这一小节内容非常多，建议的学习方法是：

首先看目录，了解这一小节主要讲的是哪几种构件
通过构件的名字猜猜它们想实现的功能，然后通过查询文档总结一下每个构件的特点，适用的场景
尝试">

    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="特喜欢秋天的人">特喜欢秋天的人</a></h1>
				<h2 class="blog-motto">keep going，多尝试，就不会害怕...</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">主页</a></li>
					
						<li><a href="/archives">归档</a></li>
					
						<li><a href="/categories">分类</a></li>
					
						<li><a href="/about">关于</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:mwplll.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/08/17/Java编程思想-第二十一章、并发（七）/" title="Java编程思想-第二十一章、并发（七）" itemprop="url">Java编程思想-第二十一章、并发（七）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="威威小威" target="_blank" itemprop="author">威威小威</a>
		
  <p class="article-time">
    <time datetime="2015-08-17T08:24:31.000Z" itemprop="datePublished"> 发表于 2015-08-17</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-7_新类库中的构件"><span class="toc-number">1.</span> <span class="toc-text">21.7 新类库中的构件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一、前言"><span class="toc-number">2.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、代码来了"><span class="toc-number">3.</span> <span class="toc-text">二、代码来了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-_CountDownLatch"><span class="toc-number">3.1.</span> <span class="toc-text">1. CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-_CyclicBarrier"><span class="toc-number">3.2.</span> <span class="toc-text">2. CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-_DelayQueue"><span class="toc-number">3.3.</span> <span class="toc-text">3. DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-_PriorityBlockingQueue"><span class="toc-number">3.4.</span> <span class="toc-text">4. PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-_ScheduledExcutor"><span class="toc-number">3.5.</span> <span class="toc-text">5. ScheduledExcutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-_Semaphore"><span class="toc-number">3.6.</span> <span class="toc-text">6. Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-_Exchanger"><span class="toc-number">3.7.</span> <span class="toc-text">7. Exchanger</span></a></li></ol></li></ol>
		
		</div>
		
		<h3 id="21-7_新类库中的构件">21.7 新类库中的构件</h3><p>Java SE5的 <strong><code>java.util.concurrent</code></strong> 包中引入了大量设计用来解决并发问题的新类。学习这些“工具类”就可以专注于自己想要实现的功能而不是线程的同步、死锁等一堆令人头疼的细节。这一小节内容非常多，建议的学习方法是：</p>
<ol>
<li>首先看目录，了解这一小节主要讲的是哪几种构件</li>
<li>通过构件的名字猜猜它们想实现的功能，然后通过查询文档总结一下每个构件的特点，适用的场景</li>
<li>尝试着去寻找项目中涉及到的点，然后具体学习这个构件的知识，之后用新构件重新实现这一块作为巩固</li>
</ol>
<p>嗯，上面总结了一下学习这个小节的步骤（其实是因为太多了。。。。。我不想全看 T_T），那么我们就把目录摘出来看看吧。</p>
<h3 id="一、前言">一、前言</h3><p>下面是21.7小节的目录。嗯，发现一共是7个构件，现在从<strong>文档</strong>出发，逐个浏览一下（Mac 下有 Dash 这样的神器真是幸福啊，hiahiahiahia~）</p>
<ul>
<li>21.7 新类库中的构件<ul>
<li>21.7.1 CountDownLatch</li>
<li>21.7.2 CyclicBarrier</li>
<li>21.7.3 DelayQueue</li>
<li>21.7.4 PriorityBlockingQueue</li>
<li>21.7.5 使用 ScheduledExecutor 的温室控制器</li>
<li>21.7.6 Semaphore</li>
<li>21.7.7 Exchanger</li>
</ul>
</li>
</ul>
<p>下面我们先简单的“望文生义”一下，然后再逐个击破：）</p>
<ul>
<li>CountDownLatch：名字直译为——倒计时锁。官方文档的描述是 A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.[一个线程同步辅助工具，可以让一个或多个线程等待直到其它线程的任务全部完成才会被唤醒。]</li>
<li>CyclicBarrier：和上面那个功能相似，只是上面的倒计时数值不能被重置，只能递减到0停止；而 CyclicBarrier 可以在倒计时数减为0之后重用（还是原来的值）</li>
<li>DelayQueue：无界的 BlockingQueue（前面生产者-消费者讲过哦），用于放置实现了 Delayed interface 的对象，其中的对象只能在到期时才能在队列中取走。<strong>这种队列是有序的，即队头对象的延期到期的时间最长。</strong></li>
<li>PriorityBlockingQueue：优先队列的 BlockingQueue，具有可阻塞的读取操作。其实就是 BlockingQueue 的优先队列实现</li>
<li>使用 ScheduledExecutor 的温室控制器：</li>
<li>Semaphore：正常的锁（concurrent.Lock 或者 synchronized）在任何时刻都只能允许一个任务访问资源，而 <strong>Semaphore （计数信号量）允许 N 个任务同时访问这个资源。</strong>（是不是有池子的感觉嘞？？）</li>
<li>Exchanger：两个任务之间交换对象的栅栏。意思是各自拥有对象，离开栅栏时，就拥有对方持有的对象了。典型就是一个任务生产对象，一个任务消费对象。（值得思考，为啥要交换？我直接用一个容器或者 BlockingQueue 完全可以解耦啊，这个到底用在哪里？）</li>
</ul>
<h3 id="二、代码来了">二、代码来了</h3><p>下面给每个构件都写个小例子，然后总结一下它们产生的原因和最佳使用场景。go go go!!</p>
<h4 id="1-_CountDownLatch">1. CountDownLatch</h4><p>文档也太详细了吧：</p>
<blockquote>
<p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p>
<p>A CountDownLatch is initialized with a given count. The <code>await</code> methods block until the current count reaches zero due to invocations of the <code>countDown()</code> method, after which all waiting threads are released and any subsequent invocations of <code>await</code> return immediately. <strong>This is a one-shot phenomenon — the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier【和 CyclicBarrier 的区别】</strong>.</p>
<p>A CountDownLatch is a versatile(多功能的) synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking <code>await</code> wait at the gate until it is opened by a thread invoking <code>countDown()</code>. A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.【这里是使用场景：count=1为开关；count=N 重复 N 次】</p>
<p>A useful property of a CountDownLatch is that it doesn’t require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an <code>await</code> until all threads could pass.</p>
</blockquote>
<p>同时文档提供了演示代码：</p>
<pre><code>Here <span class="keyword">is</span> a pair of classes <span class="keyword">in</span> which a <span class="keyword">group</span> of worker threads use two countdown latches:

<span class="number">1.</span> The first <span class="keyword">is</span> a start signal that prevents any worker <span class="keyword">from</span> proceeding until the driver <span class="keyword">is</span> ready <span class="keyword">for</span> them to proceed;
<span class="number">2.</span> The second <span class="keyword">is</span> a completion signal that allows the driver to wait until all workers have completed.

<span class="keyword">class</span> <span class="title">Driver</span> { <span class="comment">// ...</span>
   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> throws InterruptedException </span>{
     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);
     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);

     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span>
       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();

     doSomethingElse();            <span class="comment">// don't let run yet</span>
     startSignal.countDown();      <span class="comment">// let all threads proceed</span>
     doSomethingElse();
     doneSignal.await();           <span class="comment">// wait for all to finish</span>
   }
 }

 <span class="keyword">class</span> <span class="title">Worker</span> <span class="title">implements</span> <span class="title">Runnable</span> {
   <span class="keyword">private</span> final CountDownLatch startSignal;
   <span class="keyword">private</span> final CountDownLatch doneSignal;
   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) {
      <span class="keyword">this</span>.startSignal = startSignal;
      <span class="keyword">this</span>.doneSignal = doneSignal;
   }
   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
      <span class="keyword">try</span> {
        startSignal.await();
        doWork();
        doneSignal.countDown();
      } <span class="keyword">catch</span> (InterruptedException ex) {} <span class="comment">// return;</span>
   }

   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>{ ... }
 }
</code></pre><p>文档已经够清晰了，这里就不多废话了。</p>
<h4 id="2-_CyclicBarrier">2. CyclicBarrier</h4><p>直译为循环栅栏，通过它可以让<strong>一组线程全部到达某个状态后再同时执行，也就是说假如有5个线程协作完成一个任务，那么只有当每个线程都完成了各自的任务（都到达终点），才能继续运行（开始领奖）</strong>。循环的意思是当所有等待线程都被释放（也就是所有线程完成各自的任务，整个程序开始继续执行）以后，CyclicBarrier 可以被重用。而上面的 CountDownLatch 只能用一次。</p>
<p>这个的文档也非常详细：</p>
<blockquote>
<p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point[各个线程互相等待，CountDownLatch 是一个等待其他多个线程]. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other[使用场景：固定数目的线程互相等待]. The barrier is called cyclic because it can be re-used after the waiting threads are released[为什么叫做循环是因为释放后可以重用].</p>
<p>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released[一个可选的参数是 Runnable，在所有线程到达 Barrier 后，但是在释放（让他们继续运行）之前。]. This barrier action is useful for updating shared-state before any of the parties continue[为什么要有这个 Runnable ？可以在所有线程继续运行前更新共享状态等].</p>
<p>If the barrier action does not rely on the parties being suspended when it is executed, then any of the threads in the party could execute that action when it is released. To facilitate this, each invocation of await() returns the arrival index of that thread at the barrier. You can then choose which thread should execute the barrier action, for example:</p>
</blockquote>
<pre><code><span class="keyword">if</span> <span class="comment">(barrier.await()</span> == <span class="number">0</span>) { 
    <span class="comment">// log the completion of this iteration</span>
}
</code></pre><blockquote>
<p>The CyclicBarrier uses an all-or-none breakage model for failed synchronization attempts: If a thread leaves a barrier point prematurely(提前) because of interruption, failure, or timeout, all other threads waiting at that barrier point will also leave abnormally via BrokenBarrierException (or InterruptedException if they too were interrupted at about the same time).[要么全体成功，要么全体失败。和 Future 类似]</p>
<p>Memory consistency effects: Actions in a thread prior to calling await() happen-before actions that are part of the barrier action, which in turn happen-before actions following a successful return from the corresponding await() in other threads.</p>
</blockquote>
<p>举一个例子，现在有一个比赛：</p>
<blockquote>
<p>每组 5 个人，要把 A 处的球运输到10米外的 B 处，每个人可以拿2个。等10个球全部被运输到 B 处后，这个组就算是完成了任务。那么，只要5个人有一个没有完成，就不能算是完成任务。符合上面 CyclicBarrier 的应用场景。下面是这个例子的代码：</p>
</blockquote>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.util.Random;
<span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;
<span class="keyword">import</span> java.util.concurrent.CyclicBarrier;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="class"><span class="keyword">class</span> <span class="title">Player</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{

    <span class="keyword">private</span> CyclicBarrier cyclicBarrier;
    <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);

    <span class="function"><span class="keyword">public</span> <span class="title">Player</span><span class="params">(CyclicBarrier cyclicBarrier)</span> </span>{
        <span class="keyword">this</span>.cyclicBarrier = cyclicBarrier;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            <span class="comment">// 运输2个球</span>
            TimeUnit.SECONDS.sleep(rand.nextInt(<span class="number">5</span>));

            <span class="comment">// 等待其他队友完成</span>
            System.out.println(Thread.currentThread() + <span class="string">" 完成任务！等待队友 ing..."</span>);
            cyclicBarrier.await();
        } <span class="keyword">catch</span> (BrokenBarrierException e) {
            System.out.println(<span class="string">"BrokenBarrierException "</span> + e);
        } <span class="keyword">catch</span> (InterruptedException e) {
            System.out.println(<span class="string">"InterruptedException "</span> + e);
        }
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierGame</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        <span class="comment">//定义 CyclicBarrier</span>
        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, <span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="comment">//全部完成</span>
                System.out.println(<span class="string">"\n全部完成！ 举手报告 ing...\n"</span>);
                System.out.println(<span class="string">"谁来执行 Barrier 的 Runnable？(猜测是最后一个) : "</span> + Thread.currentThread());
            }
        });

        ExecutorService exec = Executors.newCachedThreadPool();
        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {
            exec.execute(<span class="keyword">new</span> Player(cyclicBarrier));
        }

        <span class="comment">/* 下面是为了验证 CyclicBarrier 能够重用
         try {
            TimeUnit.SECONDS.sleep(5);
            for(int i = 0; i &lt; 5; i++) {
                exec.execute(new Player(cyclicBarrier));
            }
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        */</span>

        exec.shutdown();
    }
}<span class="comment">/*output:
Thread[pool-1-thread-3,5,main] 完成任务！等待队友 ing...
Thread[pool-1-thread-2,5,main] 完成任务！等待队友 ing...
Thread[pool-1-thread-5,5,main] 完成任务！等待队友 ing...
Thread[pool-1-thread-1,5,main] 完成任务！等待队友 ing...
Thread[pool-1-thread-4,5,main] 完成任务！等待队友 ing...

全部完成！ 举手报告 ing...

谁来执行 Barrier 的 Runnable？(猜测是最后一个) : Thread[pool-1-thread-4,5,main]
*/</span>
</code></pre><h4 id="3-_DelayQueue">3. DelayQueue</h4><p>DelayQueue 就是一个无界队列，是用 PriorityQueue 实现的 BlockingQueue，如果要使用 DelayQueue，其中的元素必须实现 Delayed 接口，Delayed 接口有2个方法需要重写：compareTo()和 getDelay()方法。因为使用的是优先队列，所以需要确定元素之间的优先级，那么重写 compareTo()就很明显了，又为了满足 DelayQueue 的特性（每次队头是延期到期时间最长的元素），那么就需要知道元素的到期时间，而这个时间就是通过 getDelay()获取的。</p>
<ul>
<li>延迟到期时间最长：这个刚看的时候还挺迷糊的，现在知道了。就是到期之后保存时间最长的元素。比如2个元素，在10:00:00这个时间点都到期了，但是 A 元素到期后保存时间为2分钟，B 元素到期后保存时间为1分钟，那么优先级最高的肯定是 A 元素了（本质来说，这个 order 是通过小顶堆维护的，所以获取延迟到期时间最长元素的时间复杂度为 O(lgN)）。</li>
</ul>
<p>写了一个例子，但是因为输出有点问题，就看了一下 DelayQueue 的源码，发现里面的实现是委托给 PriorityQueue 的。</p>
<h4 id="4-_PriorityBlockingQueue">4. PriorityBlockingQueue</h4><p>哈哈，前面刚看完 PriorityQueue 的源码，这里就遇到了 PriorityBlockingQueue，其实 PriorityBlockingQueue就是用 PriorityQueue 实现的 BlockingQueue，所以没啥可说的。写了个例子低空掠过：</p>
<pre><code>package concurrency;

import java.util.Random;
import java.util.concurrent.PriorityBlockingQueue;

class Leader implements Comparable {
    private String name;
    private int degree;

    public Leader(String name, int degree) {
        this.name = name;
        this.degree = degree;
    }

    @Override
    public int compareTo(Object o) {
        Leader leader = (Leader) o;
        <span class="keyword">return</span> leader.degree - this.degree;
    }

    public String getName() {
        <span class="keyword">return</span> name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getDegree() {
        <span class="keyword">return</span> degree;
    }

    public void setDegree(int degree) {
        this.degree = degree;
    }

}

public class WhoGoFirst {

    // 通过随机数给领导分级别
    private static PriorityBlockingQueue&lt;Leader&gt; leaders = new PriorityBlockingQueue&lt;Leader&gt;();

    public static void watchFilm(Leader leader) {
        leaders.add(leader);
    }

    public static void goFirst(PriorityBlockingQueue&lt;Leader&gt; leaders) {
        <span class="keyword">try</span> {
            <span class="keyword">while</span> (!leaders.isEmpty()) {
                Leader leader = leaders.take();
                System.out.println(<span class="string">"级别： "</span> + leader.getDegree() + <span class="string">"的 "</span> + leader.getName() + <span class="string">" 正在撤离..."</span>);
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        Random random = new Random();
        <span class="keyword">for</span> (int i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) {
            watchFilm(new Leader(<span class="string">"leader "</span> + i, random.nextInt(<span class="number">10</span>)));
        }

        System.out.println(<span class="string">"所有领导已经就坐，开始播放电影：速度与激情7..."</span>);

        System.out.println(<span class="string">"着火了！！！"</span>);

        goFirst(leaders);

    }
}/*output:
所有领导已经就坐，开始播放电影：速度与激情<span class="number">7.</span>..
着火了！！！
级别： <span class="number">8</span>的 leader <span class="number">3</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">7</span>的 leader <span class="number">8</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">6</span>的 leader <span class="number">4</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">6</span>的 leader <span class="number">9</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">6</span>的 leader <span class="number">2</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">5</span>的 leader <span class="number">5</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">4</span>的 leader <span class="number">6</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">4</span>的 leader <span class="number">7</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">2</span>的 leader <span class="number">10</span> 正在撤离<span class="keyword">...</span>
级别： <span class="number">0</span>的 leader <span class="number">1</span> 正在撤离<span class="keyword">...</span>
*/
</code></pre><h4 id="5-_ScheduledExcutor">5. ScheduledExcutor</h4><p>这个小节讲的是定时触发任务，知道 crontab 的应该都不陌生。看完以后我 google 了一下，发现几个类似功能的类，先知道有这几个东西，用到了再具体看文档吧。</p>
<ul>
<li>Timer：单线程轮询任务列表，效率较低</li>
<li>ScheduledExcutor：并行执行</li>
<li>JCrontab：借鉴了 crontab 的语法，其区别在于 command 不再是 unix/linux 的命令，而是一个 Java 类。如果该类带参数，例如<code>com.ibm.scheduler.JCronTask2#run</code>，则定期执行 run 方法；如果该类不带参数，则默认执行 main 方法。此外，还可以传参数给 main 方法或者构造函数，例如<code>com.ibm.scheduler.JCronTask2#run Hello World</code>表示传两个参数 Hello 和 World 给构造函数</li>
<li>Quartz：Spring 就是用的这个执行定时任务的</li>
</ul>
<p>给个随便搜到的资料：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-taskschedule/" target="_blank" rel="external">几种任务调度的 Java 实现方法与比较</a></p>
<p>对于举例子的 ScheduledThreadPoolExecutor，大概看下源码，本质是使用 DelayWorkQueue 实现的 BlockingQueue。其中 DelayWorkQueue 和 DelayQueue 类似，不过没有复用 DelayQueue 中用到的 PriorityQueue，而是自己捯饬了一个新的小（大）顶堆。看来concurrent 也不是100%完美的代码呀，哈哈哈。</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorTest</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);
        BusinessTask task = <span class="keyword">new</span> BusinessTask();
        <span class="comment">//1秒后开始执行任务，以后每隔2秒执行一次</span>
        executorService.scheduleWithFixedDelay(task, <span class="number">1000</span>, <span class="number">2000</span>,TimeUnit.MILLISECONDS);
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{ 
            System.out.println(<span class="string">"任务开始..."</span>);
            <span class="comment">// doBusiness();</span>
            System.out.println(<span class="string">"任务结束..."</span>);
        }
    }
}
</code></pre><p>嗯，这个例子虽然简单，但是我想说几点：</p>
<ol>
<li>ScheduleAtFixedRate 是基于固定时间间隔进行任务调度，ScheduleWithFixedDelay 取决于每次任务执行的时间长短，是基于不固定时间间隔进行任务调度：<ol>
<li>scheduleWithFixedDelay()方法：每次执行时间为上一次任务结束起向后推一个时间间隔，即每次执行时间为：initialDelay, initialDelay+executeTime+delay, initialDelay+2<em>executeTime+2</em>delay</li>
<li>scheduleWithFixedRate()方法：每次执行时间为上一次任务开始起向后推一个时间间隔，即每次执行时间为 :initialDelay, initialDelay+period, initialDelay+2*period, …</li>
</ol>
</li>
<li>有可能上面的程序执行了一段时间后，会发现不再执行了，去查看日志，可能是doBusiness()方法中抛出了异常。但是为什么doBusiness()抛出异常就会中止定时任务的执行呢？看文档就知道了：<blockquote>
<p>Creates and executes a periodic action that becomes enabled first after the given initial delay, and subsequently with the given delay between the termination of one execution and the commencement of the next. If any execution of the task encounters an exception, subsequent executions are suppressed. Otherwise, the task will only terminate via cancellation or termination of the executor.</p>
<p>简单翻译就是：</p>
<p>创建并执行一个在给定初始延迟后首次启用的定期操作，随后，在每一次执行终止和下一次执行开始之间都存在给定的延迟。如果任务的任一执行遇到异常，就会取消后续执行。否则，只能通过执行程序的取消或终止方法来终止该任务。</p>
</blockquote>
</li>
</ol>
<p>所以上面的例子应该改成下面这样：</p>
<pre><code><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorTest</span> </span>{
    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{
        ScheduledExecutorService executorService = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">1</span>);
        BusinessTask task = <span class="keyword">new</span> BusinessTask();
        <span class="comment">//1秒后开始执行任务，以后每隔2秒执行一次</span>
        executorService.scheduleWithFixedDelay(task, <span class="number">1000</span>, <span class="number">2000</span>,TimeUnit.MILLISECONDS);
    }

    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{
        <span class="annotation">@Override</span>
        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{ 
            <span class="comment">//捕获所有的异常，保证定时任务能够继续执行</span>
            <span class="keyword">try</span>{
                System.out.println(<span class="string">"任务开始..."</span>);
                <span class="comment">// doBusiness();</span>
                System.out.println(<span class="string">"任务结束..."</span>);
            }<span class="keyword">catch</span> (Throwable e) {
                <span class="comment">// solve the exception problem</span>
            }
        }
    }
}
</code></pre><h4 id="6-_Semaphore">6. Semaphore</h4><p>Semaphore 是一个计数信号量，平常的锁（来自 concurrent.locks 或者内建的 synchronized)再任何时刻都只能允许一个任务访问一项资源，但是 Semaphore 允许 N 个任务同时访问这个资源。你还可以将信号量看做是在向外分发使用资源的“许可证”，尽管实际上没有使用任何许可证对象。</p>
<p>总结来说，一般的锁是保证一个资源只能被一个任务访问；Semaphore 是保证一堆资源可以同时有多个任务访问。举个例子，现在有一个厕所，5个坑位，如果使用 synchronized 的话，同步厕所就只能让1个人进入，浪费了4个坑位；稍微往前一步是使用 BlockingQueue（如果你用 synchronized 来同步5个坑位就很复杂多了），再往前一步，concurrent 提供了 Semaphore ，它通过 acquire()和 release()来保证资源的分发使用。</p>
<p>下面我们通过实现一个资源池来说明，具体的场景完全在例子中注释：）</p>
<pre><code><span class="keyword">package</span> concurrency;

<span class="keyword">import</span> java.util.ArrayList;
<span class="keyword">import</span> java.util.List;
<span class="keyword">import</span> java.util.concurrent.ExecutorService;
<span class="keyword">import</span> java.util.concurrent.Executors;
<span class="keyword">import</span> java.util.concurrent.Future;
<span class="keyword">import</span> java.util.concurrent.Semaphore;
<span class="keyword">import</span> java.util.concurrent.TimeUnit;

<span class="comment">// 抽象成一个资源池</span>
<span class="class"><span class="keyword">class</span> <span class="title">Pool</span>&lt;<span class="title">T</span>&gt; </span>{
    <span class="keyword">private</span> <span class="keyword">int</span> size;
    <span class="keyword">private</span> List&lt;T&gt; items = <span class="keyword">new</span> ArrayList&lt;T&gt;();
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>[] checkedOut;
    <span class="keyword">private</span> Semaphore available;

    <span class="comment">// 要放入资源池的资源数目，如果请求线程数目大于资源池资源数目，就需要阻塞等待</span>
    <span class="function"><span class="keyword">public</span> <span class="title">Pool</span><span class="params">(Class&lt;T&gt; classObject, <span class="keyword">int</span> size)</span> </span>{
        <span class="keyword">this</span>.size = size;
        checkedOut = <span class="keyword">new</span> <span class="keyword">boolean</span>[size];
        <span class="javadoc">/**
         * 第二个参数的含义:&lt;br&gt;
         * 
         * true: 代表的是公平竞争&lt;br&gt;
         * 没有第二个参数或者false：代表随机选中等待许可证的线程
         */</span>
        available = <span class="keyword">new</span> Semaphore(size, <span class="keyword">true</span>);
        <span class="comment">// Load pool with objects that can be checked out:</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {
            <span class="keyword">try</span> {
                <span class="comment">// Assumes a default constructor:</span>
                items.add(classObject.newInstance());
            } <span class="keyword">catch</span> (Exception e) {
                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);
            }
        }
    }

    <span class="function"><span class="keyword">public</span> T <span class="title">checkOut</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>{
        available.acquire();
        <span class="keyword">return</span> getItem();
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkIn</span><span class="params">(T x)</span> </span>{
        <span class="keyword">if</span> (releaseItem(x))
            available.release();
    }

    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> T <span class="title">getItem</span><span class="params">()</span> </span>{
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)
            <span class="keyword">if</span> (!checkedOut[i]) {
                checkedOut[i] = <span class="keyword">true</span>;
                <span class="keyword">return</span> items.get(i);
            }
        <span class="keyword">return</span> <span class="keyword">null</span>;
    }

    <span class="comment">// 回收资源</span>
    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">releaseItem</span><span class="params">(T item)</span> </span>{
        <span class="keyword">int</span> index = items.indexOf(item);
        <span class="comment">// not in the list</span>
        <span class="keyword">if</span> (index == -<span class="number">1</span>)
            <span class="keyword">return</span> <span class="keyword">false</span>;
        <span class="keyword">if</span> (checkedOut[index]) {
            checkedOut[index] = <span class="keyword">false</span>;
            <span class="keyword">return</span> <span class="keyword">true</span>;
        }
        <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// wasn't checked out</span>
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Fat</span> </span>{
    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">double</span> d; <span class="comment">// 阻止指令优化</span>
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;

    <span class="function"><span class="keyword">public</span> <span class="title">Fat</span><span class="params">()</span> </span>{
        <span class="comment">// Expensive, interruptible operation</span>
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10000</span>; i++) {
            d += (Math.PI + Math.E) / (<span class="keyword">double</span>) i;
        }
    }

    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>{
        System.out.println(<span class="keyword">this</span>);
    }

    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"Fat id: "</span> + id;
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">CheckoutTask</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Runnable</span> </span>{
    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> counter = <span class="number">0</span>;
    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id = counter++;
    <span class="keyword">private</span> Pool&lt;T&gt; pool;

    <span class="function"><span class="keyword">public</span> <span class="title">CheckoutTask</span><span class="params">(Pool&lt;T&gt; pool)</span> </span>{
        <span class="keyword">this</span>.pool = pool;
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
        <span class="keyword">try</span> {
            T item = pool.checkOut();
            System.out.println(<span class="keyword">this</span> + <span class="string">"checked out "</span> + item);
            TimeUnit.SECONDS.sleep(<span class="number">1</span>);
            System.out.println(<span class="keyword">this</span> + <span class="string">"checked in "</span> + item);
            pool.checkIn(item);
        } <span class="keyword">catch</span> (InterruptedException e) {
            <span class="comment">// 终止</span>
        }
    }

    <span class="annotation">@Override</span>
    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>{
        <span class="keyword">return</span> <span class="string">"checkoutTask "</span> + id + <span class="string">" "</span>;
    }
}

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>{
    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SIZE = <span class="number">25</span>;

    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{
        <span class="comment">// 创建一个 Fat 的资源池，大小为25</span>
        <span class="keyword">final</span> Pool&lt;Fat&gt; pool = <span class="keyword">new</span> Pool&lt;Fat&gt;(Fat.class, SIZE);

        <span class="comment">// 启动25个线程开始玩，从25个资源池 checkout</span>
        ExecutorService exec = Executors.newCachedThreadPool();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {
            exec.execute(<span class="keyword">new</span> CheckoutTask&lt;Fat&gt;(pool));
        }
        System.out.println(<span class="string">"All CheckoutTasks created"</span>);

        <span class="comment">// 然后用主线程把所有的 Fat 全灌到 list 中了，资源池为空</span>
        List&lt;Fat&gt; list = <span class="keyword">new</span> ArrayList&lt;Fat&gt;();
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; i++) {
            Fat fat = pool.checkOut();
            System.out.println(i + <span class="string">": main() thread checked out "</span>);
            fat.operation();
            list.add(fat);
        }

        <span class="comment">// 还记得 Future 会阻塞吗？因为主线程把25个资源全 checkout 了，所以再 checkOut 肯定阻塞了</span>
        Future&lt;?&gt; blocked = exec.submit(<span class="keyword">new</span> Runnable() {
            <span class="annotation">@Override</span>
            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{
                <span class="keyword">try</span> {
                    <span class="comment">// Semaphore prevents additional checkout,</span>
                    <span class="comment">// so call is blocked:</span>
                    pool.checkOut();
                } <span class="keyword">catch</span> (InterruptedException e) {
                    System.out.println(<span class="string">"checkOut() Interrupted"</span>);
                }
            }
        });
        <span class="comment">// 因为 Semaphore 是阻塞的，所以10s 还拿不到的情况下，就取消 blocked 线程的工作</span>
        TimeUnit.SECONDS.sleep(<span class="number">10</span>);
        blocked.cancel(<span class="keyword">true</span>); <span class="comment">// Break out of blocked call</span>
        System.out.println(<span class="string">"\n\n\nChecking in objects in "</span> + list);
        <span class="keyword">for</span> (Fat f : list) {
            pool.checkIn(f);
        }
        <span class="keyword">for</span> (Fat f : list) {
            pool.checkIn(f); <span class="comment">// Second checkIn ignored</span>
        }
        exec.shutdown();
    }

}<span class="comment">/*output:
checkoutTask 1 checked out Fat id: 1
checkoutTask 4 checked out Fat id: 4
checkoutTask 3 checked out Fat id: 3
checkoutTask 5 checked out Fat id: 5
checkoutTask 2 checked out Fat id: 2
checkoutTask 6 checked out Fat id: 6
checkoutTask 0 checked out Fat id: 0
checkoutTask 7 checked out Fat id: 7
checkoutTask 8 checked out Fat id: 8
checkoutTask 9 checked out Fat id: 9
checkoutTask 10 checked out Fat id: 10
checkoutTask 11 checked out Fat id: 11
checkoutTask 12 checked out Fat id: 12
checkoutTask 13 checked out Fat id: 13
checkoutTask 14 checked out Fat id: 14
checkoutTask 15 checked out Fat id: 15
checkoutTask 16 checked out Fat id: 16
checkoutTask 17 checked out Fat id: 17
checkoutTask 18 checked out Fat id: 18
checkoutTask 19 checked out Fat id: 19
checkoutTask 20 checked out Fat id: 20
checkoutTask 21 checked out Fat id: 21
checkoutTask 22 checked out Fat id: 22
checkoutTask 23 checked out Fat id: 23
All CheckoutTasks created
checkoutTask 24 checked out Fat id: 24
checkoutTask 4 checked in Fat id: 4
checkoutTask 2 checked in Fat id: 2
checkoutTask 0 checked in Fat id: 0
checkoutTask 3 checked in Fat id: 3
checkoutTask 7 checked in Fat id: 7
checkoutTask 9 checked in Fat id: 9
checkoutTask 5 checked in Fat id: 5
checkoutTask 11 checked in Fat id: 11
checkoutTask 12 checked in Fat id: 12
checkoutTask 13 checked in Fat id: 13
checkoutTask 14 checked in Fat id: 14
checkoutTask 15 checked in Fat id: 15
checkoutTask 1 checked in Fat id: 1
checkoutTask 17 checked in Fat id: 17
checkoutTask 16 checked in Fat id: 16
checkoutTask 10 checked in Fat id: 10
checkoutTask 8 checked in Fat id: 8
0: main() thread checked out 
Fat id: 0
1: main() thread checked out 
Fat id: 1
2: main() thread checked out 
Fat id: 2
3: main() thread checked out 
Fat id: 3
4: main() thread checked out 
Fat id: 4
5: main() thread checked out 
Fat id: 5
6: main() thread checked out 
Fat id: 7
7: main() thread checked out 
Fat id: 8
8: main() thread checked out 
Fat id: 9
9: main() thread checked out 
Fat id: 10
10: main() thread checked out 
Fat id: 11
11: main() thread checked out 
Fat id: 12
12: main() thread checked out 
Fat id: 13
13: main() thread checked out 
Fat id: 14
14: main() thread checked out 
Fat id: 15
15: main() thread checked out 
Fat id: 16
16: main() thread checked out 
Fat id: 17
checkoutTask 6 checked in Fat id: 6
checkoutTask 18 checked in Fat id: 18
checkoutTask 20 checked in Fat id: 20
checkoutTask 21 checked in Fat id: 21
checkoutTask 22 checked in Fat id: 22
checkoutTask 23 checked in Fat id: 23
checkoutTask 24 checked in Fat id: 24
17: main() thread checked out 
Fat id: 6
18: main() thread checked out 
Fat id: 18
19: main() thread checked out 
Fat id: 20
20: main() thread checked out 
Fat id: 21
checkoutTask 19 checked in Fat id: 19
21: main() thread checked out 
Fat id: 22
22: main() thread checked out 
Fat id: 19
23: main() thread checked out 
Fat id: 23
24: main() thread checked out 
Fat id: 24
checkOut() Interrupted



Checking in objects in [Fat id: 0, Fat id: 1, Fat id: 2, Fat id: 3, Fat id: 4, Fat id: 5, Fat id: 7, Fat id: 8, Fat id: 9, Fat id: 10, Fat id: 11, Fat id: 12, Fat id: 13, Fat id: 14, Fat id: 15, Fat i
d: 16, Fat id: 17, Fat id: 6, Fat id: 18, Fat id: 20, Fat id: 21, Fat id: 22, Fat id: 19, Fat id: 23, Fat id: 24]
*/</span>
</code></pre><h4 id="7-_Exchanger">7. Exchanger</h4><p>终于来到21.7小节的最后一个构件了！！！！</p>
<p>这个构件很简单，是为了让<strong>两个任务交换对象，当两个任务进入 Exchanger 提供的“栅栏”时，他们各自拥有一个对象，当它们离开时，都拥有了之前由对方拥有的对象</strong>。为什么要有这么个东西呢？考虑下面的场景：</p>
<blockquote>
<p>一个任务在创建对象，这些对象的生产/销毁代价都非常高。上面 Semaphore 的例子还算靠谱，因为我用完了资源并没有销毁，直接还给资源池了，然后立马可以被复用。但是如果两个线程需要知晓对方的工作状态信息，就可以用 Exchanger 交换各自的工作状态。</p>
</blockquote>
<p>更具体的使用场景还没有仔细想，大概搜了下都是缓存交换（一个读，一个写），比如这个：<a href="http://lixuanbin.iteye.com/blog/2166772" target="_blank" rel="external">java.util.concurrent.Exchanger应用范例与原理浅析</a>。我只是简单写了个 demo 备忘，用到的时候知道有这个东西，其他的再看文档吧：</p>
<pre><code>package concurrency;

import java.util.ArrayList;
import java.util.<span class="keyword">List</span>;
import java.util.Random;
import java.util.concurrent.Exchanger;

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>{

    <span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) {
        Exchanger&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();
        <span class="keyword">new</span> Consumer(exchanger).start();
        <span class="keyword">new</span> Producer(exchanger).start();
    }

}

<span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{
    <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();
    Exchanger&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; exchanger = <span class="keyword">null</span>;

    <span class="keyword">public</span> Producer(Exchanger&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; exchanger) {
        super();
        this.exchanger = exchanger;
    }

    @Override
    <span class="keyword">public</span> void run() {
        System.out.println(<span class="string">"this is Producer"</span>);
        Random rand = <span class="keyword">new</span> Random();
        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) {
            <span class="keyword">list</span>.clear();
            <span class="keyword">list</span>.add(rand.nextInt(<span class="number">10000</span>));
            <span class="keyword">list</span>.add(rand.nextInt(<span class="number">10000</span>));
            <span class="keyword">list</span>.add(rand.nextInt(<span class="number">10000</span>));
            <span class="keyword">list</span>.add(rand.nextInt(<span class="number">10000</span>));
            <span class="keyword">list</span>.add(rand.nextInt(<span class="number">10000</span>));
            <span class="keyword">try</span> {
                System.out.println(<span class="string">"producer exchanger..."</span>);
                <span class="keyword">list</span> = exchanger.exchange(<span class="keyword">list</span>);
                System.out.println(<span class="string">"Producer is done"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

<span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{
    <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();
    Exchanger&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; exchanger = <span class="keyword">null</span>;

    <span class="keyword">public</span> Consumer(Exchanger&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; exchanger) {
        super();
        this.exchanger = exchanger;
    }

    @Override
    <span class="keyword">public</span> void run() {
        System.out.println(<span class="string">"this is Consumer"</span>);
        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; <span class="number">1</span>; i++) {
            <span class="keyword">try</span> {
                System.out.println(<span class="string">"consumer blocking..."</span>);
                <span class="keyword">list</span> = exchanger.exchange(<span class="keyword">list</span>);
                System.out.println(<span class="string">"consumer is done"</span>);
            } <span class="keyword">catch</span> (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.<span class="keyword">print</span>(<span class="keyword">list</span>.get(<span class="number">0</span>) + <span class="string">", "</span>);
            System.out.<span class="keyword">print</span>(<span class="keyword">list</span>.get(<span class="number">1</span>) + <span class="string">", "</span>);
            System.out.<span class="keyword">print</span>(<span class="keyword">list</span>.get(<span class="number">2</span>) + <span class="string">", "</span>);
            System.out.<span class="keyword">print</span>(<span class="keyword">list</span>.get(<span class="number">3</span>) + <span class="string">", "</span>);
            System.out.println(<span class="keyword">list</span>.get(<span class="number">4</span>) + <span class="string">", "</span>);
        }
    }
}<span class="comment">/*output:
this is Consumer
consumer blocking...
this is Producer
producer exchanger...
Producer is done
consumer is done
7481, 9360, 6010, 4630, 4338, 
*/</span>
</code></pre>  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Java/">Java</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Java编程思想/">Java编程思想</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（七）/" data-title="Java编程思想-第二十一章、并发（七） | 特喜欢秋天的人" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/08/17/Java编程思想-第二十一章、并发（八）/" title="Java编程思想-第二十一章、并发（八）">
  <strong>上一篇：</strong><br/>
  <span>
  Java编程思想-第二十一章、并发（八）</span>
</a>
</div>


<div class="next">
<a href="/2015/08/17/Java编程思想-第二十一章、并发（六）/"  title="Java编程思想-第二十一章、并发（六）">
 <strong>下一篇：</strong><br/> 
 <span>Java编程思想-第二十一章、并发（六）
</span>
</a>
</div>

</nav>

	
<section id="comments" class="comment">
	<div class="ds-thread" data-thread-key="2015/08/17/Java编程思想-第二十一章、并发（七）/" data-title="Java编程思想-第二十一章、并发（七）" data-url="http://mwplll.github.io/2015/08/17/Java编程思想-第二十一章、并发（七）/"></div>
</section>


</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#21-7_新类库中的构件"><span class="toc-number">1.</span> <span class="toc-text">21.7 新类库中的构件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一、前言"><span class="toc-number">2.</span> <span class="toc-text">一、前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二、代码来了"><span class="toc-number">3.</span> <span class="toc-text">二、代码来了</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-_CountDownLatch"><span class="toc-number">3.1.</span> <span class="toc-text">1. CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-_CyclicBarrier"><span class="toc-number">3.2.</span> <span class="toc-text">2. CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-_DelayQueue"><span class="toc-number">3.3.</span> <span class="toc-text">3. DelayQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-_PriorityBlockingQueue"><span class="toc-number">3.4.</span> <span class="toc-text">4. PriorityBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-_ScheduledExcutor"><span class="toc-number">3.5.</span> <span class="toc-text">5. ScheduledExcutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-_Semaphore"><span class="toc-number">3.6.</span> <span class="toc-text">6. Semaphore</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-_Exchanger"><span class="toc-number">3.7.</span> <span class="toc-text">7. Exchanger</span></a></li></ol></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/C/" title="C">C<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/Java/" title="Java">Java<sup>13</sup></a></li>
		  
		
		  
			<li><a href="/categories/hexo/" title="hexo">hexo<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/leetcode/" title="leetcode">leetcode<sup>2</sup></a></li>
		  
		
		  
			<li><a href="/categories/markdown/" title="markdown">markdown<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/svn/" title="svn">svn<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/求职笔试面试/" title="求职笔试面试">求职笔试面试<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/算法/" title="算法">算法<sup>13</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/算法/" title="算法">算法<sup>13</sup></a></li>
			
		
			
				<li><a href="/tags/Java编程思想/" title="Java编程思想">Java编程思想<sup>12</sup></a></li>
			
		
			
				<li><a href="/tags/树/" title="树">树<sup>6</sup></a></li>
			
		
			
				<li><a href="/tags/基础/" title="基础">基础<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/排序/" title="排序">排序<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/c/" title="c">c<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/数据结构/" title="数据结构">数据结构<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/leetcode/" title="leetcode">leetcode<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Java/" title="Java">Java<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/经验/" title="经验">经验<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/散列/" title="散列">散列<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/操作系统/" title="操作系统">操作系统<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/面试/" title="面试">面试<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/堆/" title="堆">堆<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/svn/" title="svn">svn<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/C/" title="C">C<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
    </ul>
</div>

  


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<section class="info">
		<p> Hello ,I&#39;m Mao Weipeng in ZJU. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
		<a href="mailto:maoweipeng@126.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2015 
		
		<a href="/about" target="_blank" title="威威小威">威威小威</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<div class="qrcode clearfix"><span>扫描二维码分享到微信朋友圈</span><a class="qrclose" href="#nothing"></a><strong>Loading...Please wait</strong><img id="qrcode-pic" data-src="http://s.jiathis.com/qrcode.php?url=' + encodedUrl + '"/></div>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);
  $('.article-share-qrcode').click(function(){
    var imgSrc = $('#qrcode-pic').attr('data-src');
    $('#qrcode-pic').attr('src', imgSrc);
    $('#qrcode-pic').load(function(){
        $('.qrcode strong').text(' ');
    });
  });
});     
</script>



<script type="text/javascript">
  var duoshuoQuery = {short_name:"mwplll"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
    || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 







<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3Fnull' type='text/javascript'%3E%3C/script%3E"));
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
